### Решение задачи точного поиска набора образцов (NUM == 1).

Вход:

Первая строка содержит текст (T, 1 ≤ |T| ≤ 100000).

Вторая - число $n (1 ≤ n ≤ 3000)$, каждая следующая из n строк содержит шаблон из набора $P = {p_1,…,p_n}$ $1 ≤ |p_i| ≤ 75$

Все строки содержат символы из алфавита {A,C,G,T,N}

Выход:

Все вхождения образцов из P в T.

Каждое вхождение образца в текст представить в виде двух чисел - i p
Где i - позиция в тексте (нумерация начинается с 1), с которой начинается вхождение образца с номером p (нумерация образцов начинается с 1).

Строки выхода должны быть отсортированы по возрастанию, сначала номера позиции, затем номера шаблона.
    
    Sample Input:
    NTAG
    3
    TAGT
    TAG
    T
    Sample Output:
    2 2
    2 3
---
### Решение задачи точного поиска для одного образца с джокером с использованием реализации точного множественного поиска (NUM == 2).
В шаблоне встречается специальный символ, именуемый джокером (wild card), который "совпадает" с любым символом. По заданному содержащему шаблоны образцу P необходимо найти все вхождения Р в текст Т.

Например, образец аb??с? с джокером ? встречается дважды в тексте xabvccbababcax.

Символ джокер не входит в алфавит, символы которого используются в T. Каждый джокер соответствует одному символу, а не подстроке неопределённой длины. В шаблон входит хотя бы один символ не джокер, т.е. шаблоны вида ??? недопустимы.

Все строки содержат символы из алфавита {A,C,G,T,N}

Вход:

Текст (T, 1 ≤ |T| ≤ 100000)

Шаблон (P, 1 ≤ |P| ≤ 40)

Символ джокера

Выход:

Строки с номерами позиций вхождений шаблона (каждая строка содержит только один номер).

Номера должны выводиться в порядке возрастания.

    Sample Input:
    ACTANCA
    A$$A$
    $
    Sample Output:
    1

---
# Описание алгоритма
Алгоритм Ахо-Корасик позволяет найти все вхождения заданных подстрок в другой строке. Поиск вхождений осуществляется с помощью построенного конечного автомата. Переход автомата в какое-либо состояние говорит о наличии вхождения соответствующего данному состоянию искомой подстроки в строке поиска. Переходы осуществляются в соответствии с символами в строке поиска.

Для построения автомата в начале нужно построить бор. Узлы бора можно понимать как состояния автомата, а корень как начальное состояние.

Узлы бора, в которых заканчиваются строки, становятся терминальными. Построение начинается с корня, каждая искомая строка добавляется в бор, отсутствующие переходы создаются.

Затем построенный бор дополняется суффиксными ссылками, которые ведут к состоянию, соответствующему набольшему префиксу данного бора, который является суффиксом строки текущего состояния. Для нахождения суффиксных ссылок можно использовать суффиксную ссылку родителя. Пусть к данному состоянию ведет символ С. В таком случае необходимо осуществить переход по суффиксной ссылке родителя и если оттуда есть переход в С, то состояние, в которое ведет этот переход, является искомой суффиксной ссылкой. В противном случае необходимо продолжить осуществление переходов по суффиксной ссылке до тех пор, пока не будет найдена соответствующая ссылка или пока не будет встречено коревое состояние.

Для того чтобы найти все вхождения в текст заданного шаблона с масками Q, необходимо обнаружить вхождения в текст всех его безмасочных кусков. Пусть ${Q1,…,Qk}$ — набор подстрок Q, разделенных масками, и пусть ${l_1,…,l_k}$ — их стартовые позиции в Q. Например, шаблон abφφcφ содержит две подстроки без масок ab и c и их стартовые позиции соответственно 1 и 5. Для алгоритма понадобится массив C. $C[i]$ — количество встретившихся в тексте безмасочных подстрок шаблона, который начинается в тексте на позиции i. Тогда появление подстроки $Q_i$ в тексте на позиции j будет означать возможное появление шаблона на позиции $j−l_i+1$.
1.	Используя алгоритм Ахо-Корасик, находим безмасочные подстроки шаблона Q: когда находим $Q_i$ в тексте T на позиции j, увеличиваем на единицу $C[j−l_i+1]$.
2.	Каждое i, для которого $C[i]=k$, является стартовой позицией появления шаблона Q в тексте.

Рассмотрим подстроку текста $T[i…i+n−1]$. Равенство $C[i]=k$ будет означать, что подстроки текста $T[i+l_1…i+l_1+|Q_1|−1],T[i+l_2…i+l_2+|Q_2|−1]$ и так далее будут равны соответственно безмасочным подстрокам шаблона ${Q1,…,Qk}$. Остальная часть шаблона является масками, поэтому шаблон входит в текст на позиции i.

---
# Индивидуализация (IND == 1)
Реализован режим поиска, при котором все найденные образцы не пересекаются в строке поиска (т.е. некоторые вхождения не будут найдены; решение задачи неоднозначно).

Для реализации индивидуального варианта в случае первого задания после нахождения вхождения какого-либо образца в тексте переходим в корень дерева. Для второго задания рассматриваем элементы массива C в интервале индексов от i – len(sample) + 1 до  i + len(sample), где i – индекс начала найденной части образца в тексте а len(sample) – длина изначального образца(с джокерами). Если в данном промежутке есть элемент, равный количеству частей, на которые был разделен образец, то переходим к следующей интерации, иначе – увеличиваем значение С[i] на 1.

---
# Оценка сложности алгоритма
Таблица переходов автомата хранится с помощью ассоциативного массива. Сложность алгоритма по операциям будет равна $O((M+N)*log(k)+t)$, где M – суммарная длина всех шаблонов, N – длина текста, в котором осуществляется поиск, k – размер алфавита, t – общая длина всех возможных вхождений образцов. Сложность алгоритма по памяти: O (M).

# Тестирование
Задача №1:
| Ввод                                                       | Вывод                         |
|------------------------------------------------------------|-------------------------------|
| NTAG<br>3<br>TAGT<br>TAG<br>T                              | 2 2<br>2 3   <br>             |
| CCCA<br>2<br>CA<br>CC                                      | 1 1<br>2 1<br>3 1             |
| TCGATTACNAGTANNTA<br>5<br>GTA<br>NN<br>ANNA<br>TAG<br>C    | 2 5<br>8 5<br>11 1<br>14 2    |

Задача №2:
| Ввод                                    | Вывод               |
|-----------------------------------------|---------------------|
| NACGNTTACGGTCACNN<br>AC??T?AC??<br>?    | 2<br>8              |
| AGGAGAGAGA<br>**G<br>\*                  | 1<br>3<br>5<br>7    |
| ACGACTACNACG<br>AC*AC<br>\*              | 1<br>4<br>7         |

Индивидуализация:
| Ввод                                                 | Вывод                 |
|------------------------------------------------------|-----------------------|
| ACNTGNGATANGAT<br>xTxNGxT<br>x                       |    <br>3              |
| NACGNTTACGGTCACNN<br>AC**T*AC**<br>\*                 | 2                     |
| ACTANCATANGAT<br>4<br>ACTAN<br>TAN<br>CAT<br>NGAT    | 1 1<br>6 3<br>10 4    |
