### Реализация алгоритма КМП и для заданных шаблона P (∣P∣≤15000) и текста T (∣T∣≤5000000) нахождение всех вхождений P в T (NUM == 1)
Вход:

Первая строка - P 

Вторая строка - T

Выход:

Индексы начал вхождений P в T, разделенных запятой, если P не входит в T, то −1.

    Sample Input:
    ab
    abab
    Sample Output:
    0,2
    
---
### Заданы две строки A (|A| 5000000) и B (|B| 5000000) (NUM == 2).
Определить, является ли A циклическим сдвигом B (это значит, что A и B имеют одинаковую длину и A состоит из суффикса B, склеенного с префиксом B). Например, defabc является циклическим сдвигом abcdef.

Вход:

Первая строка - A

Вторая строка - B

Выход:

Если A является циклическим сдвигом B, индекс начала строки B в A, иначе -1. Если возможно несколько сдвигов вывести первый индекс.

    Sample Input:
    defabc
    abcdef
    Sample Output:
    3

---
Префикс-функция строки π(S,i) – это длина наибольшего префикса строки S[1..i], который не совпадает с этой строкой и одновременно является ее суффиксом. Проще говоря, это длина наиболее длинного начала строки, являющегося также и ее концом.
Предположим, что π(S,i)=k. Отметим следующие свойства префикс-функции.
1.	Если S[i+1]=S[k+1], то π(S,i+1)=k+1.
2.	S[1..π(S,k)] является суффиксом строки S[1..i].  Действительно, если строка S[1..i] оканчивается строкой S[1… π(S,i)]=S[1..k], а строка S[1..k] оканчивается строкой S[1..π(S,k)], то и строка S[1..i] оканчивается строкой S[1..π(S,k)].
3.	∀ j∈(k,i), S[1..j] не является суффиксом строки S[1..i]. В противном случае было бы неверным предположение π(S,i)=k, так как j>k.

# Описание Алгоритма
Префикс функцией будем называть список значений для исходной строки. Рассмотренные в теоретических положениях свойства позволяют получить алгоритм вычисления префикс-функции. Пусть π(S,i)=k. Необходимо вычислить π(S,i+1). 
1.  Если S[i+1]=S[k+1], то π(S,i+1)=k+1.
2.	Иначе, если k=0, то π(S,i+1)=0.
3.	Иначе положить k:=π(S,k) и перейти к шагу 1.

Ключевым моментом для понимания сути алгоритма является тот факт, что если найденный на предыдущем шаге суффикс не может быть расширен на следующую позицию, то мы пытаемся рассматривать меньшие суффиксы до тех пор, пока это возможно.

Сам алгоритм КМП состоит в следующем:
1.	Построить префикс-функцию образца S, обозначим ее F.
2.	Положить k = 0, i = 0.
3.	Сравнить символы S[k] и T[i]. Если символы равны, увеличить k на 1. Если при этом k стало равно длине образца, то вхождение образца S в строку T найдено, индекс вхождения равен i – |S| + 1. Индекс вхождения записывается в массив индексов, берется следующее значение префикс функции и алгоритм продолжается. Если символы не равны, используем префикс-функцию для оптимизации сдвигов. Пока k > 0, присвоим k = F[k–1] и перейдем в начало шага 3.
4.	Пока i < |T|, увеличиваем i на 1 и переходим в шаг 3.

Алгоритм для проверки циклического сдвига сначала проверяет, совпадают ли длины переданных строк. Если они различны – результат равен -1. В противном случае строка происходит конкатенация строк B и B и происходил запуск алгоритма КМП поиска подстроки A в подстроке B+B до первого вхождения.

# Сложность алгоритма
Сложность алгоритма по времени составляет O(m + n), а по памяти O(m) , где m — длина подстроки, n — длина строки, т. к. мы обходим один раз в цикле всю строку и занимаем в памяти список префикс функции от подстроки.
